---
title: "Bootstrap"
date: 2025-06-18
toc: true

execute:
  echo: false
---

## Introduction

Bootstrapping is a powerful statistical resampling method that allows us to estimate the sampling distribution of a statistic without making strong parametric assumptions. Introduced by Bradley Efron in 1979, the bootstrap provides a way to quantify uncertainty, construct confidence intervals, and perform hypothesis tests when traditional analytical methods are difficult or impossible to apply.

The core idea is elegantly simple: if we don't know the true population distribution, we can use our sample as a proxy for the population and repeatedly resample from it to understand how our statistic would behave across different samples.

### Connection to Particle Filtering

The bootstrap principle shares fundamental similarities with particle filtering, which we explored in the previous chapter. Both methods use **resampling** to approximate complex distributions:

- **Particle filters** resample particles based on their importance weights to maintain a good approximation of the posterior distribution over time.
- **Bootstrap methods** resample from observed data to approximate the sampling distribution of statistics.

In particle filtering, we saw how resampling addresses particle degeneracy - when most particles have negligible weights. Similarly, bootstrap resampling addresses the problem of not knowing the true population distribution by treating our sample as a "mini-population" to resample from.


### The Bootstrap Principle

Consider a sample $\mathbf{X} = \{X_1, X_2, \ldots, X_n\}$ drawn from an unknown distribution $F$. We want to understand the sampling distribution of some statistic $T(\mathbf{X})$ - for example, the sample mean, median, or a regression coefficient.

The **bootstrap principle** states that:

> The relationship between the sample and the population mirrors the relationship between a bootstrap sample and the original sample.

Mathematically:
$$
\text{Population} \rightarrow \text{Sample} \quad \text{as} \quad \text{Sample} \rightarrow \text{Bootstrap Sample}
$$

This analogy allows us to approximate the unknown sampling distribution $F_{T}$ of our statistic using the empirical distribution of bootstrap statistics.

## Non-parametric Bootstrap

### The Empirical Distribution Function

The foundation of non-parametric bootstrapping lies in the **empirical distribution function** (EDF). For a given sample $\mathbf{x} = \{x_1, x_2, \ldots, x_n\}$, the EDF is defined as:

$$
\hat{F}_n(t) = \frac{1}{n} \sum_{i=1}^{n} \mathbf{1}(x_i \leq t)
$$

The EDF serves as our best non-parametric estimate of the true population distribution $F$. It assigns equal probability $1/n$ to each observed data point, effectively treating our sample as if it were the entire population. This approach makes no assumptions about the underlying distributional form, making it widely applicable across different data types and statistical problems.

### Bootstrap Sampling Procedure

The non-parametric bootstrap method generates new samples by resampling with replacement from the original data. This process mimics drawing new samples from the population, but uses the empirical distribution as a surrogate for the unknown true distribution.

::: {.callout-note}
## Non-parametric Bootstrap Algorithm

**Input**: Original sample $\mathbf{x} = \{x_1, x_2, \ldots, x_n\}$, number of bootstrap samples $B$

**For** $b = 1, 2, \ldots, B$:

1. **Resample**: Draw $n$ observations with replacement from $\mathbf{x}$ to obtain $\mathbf{x}^{*(b)} = \{x_1^{*(b)}, x_2^{*(b)}, \ldots, x_n^{*(b)}\}$
2. **Compute**: Calculate the statistic of interest $T^{*(b)} = T(\mathbf{x}^{*(b)})$

**Output**: Bootstrap distribution $\{T^{*(1)}, T^{*(2)}, \ldots, T^{*(B)}\}$
:::

Each bootstrap sample $\mathbf{x}^{*(b)}$ has the same size as the original sample but may contain repeated observations while omitting others entirely. The collection of bootstrap statistics $\{T^{*(1)}, T^{*(2)}, \ldots, T^{*(B)}\}$ forms an approximation to the sampling distribution of $T$.

### Mathematical Foundation

The central principle underlying the bootstrap is that the distribution of bootstrap statistics $T_n^*$ approximates the true sampling distribution of $T_n$. Formally, we rely on the approximation that the bootstrap distribution conditional on the observed data mimics the sampling distribution conditional on the true population.

From the bootstrap samples, we can estimate key properties of our statistic:

**Bootstrap Estimate of Bias**:
$$
\text{bias}_{\text{boot}}(T_n) = \mathbb{E}[T_n^* | \mathbf{x}] - T_n = \frac{1}{B} \sum_{b=1}^{B} T^{*(b)} - T_n
$$

**Bootstrap Estimate of Variance**:
$$
\text{var}_{\text{boot}}(T_n) = \text{Var}(T_n^* | \mathbf{x}) = \frac{1}{B-1} \sum_{b=1}^{B} (T^{*(b)} - \bar{T}^*)^2
$$

where $\bar{T}^* = \frac{1}{B} \sum_{b=1}^{B} T^{*(b)}$ represents the mean of the bootstrap statistics.

### Bootstrap Confidence Intervals

The bootstrap enables multiple approaches for constructing confidence intervals, each with different assumptions and properties.

#### Normal Approximation Method

When the bootstrap distribution is approximately normal, we can construct confidence intervals using:

$$
\text{CI}_{1-\alpha} = T_n \pm z_{\alpha/2} \cdot \sqrt{\text{var}_{\text{boot}}(T_n)}
$$

where $z_{\alpha/2}$ is the $(1-\alpha/2)$ quantile of the standard normal distribution.

#### Percentile Method

The percentile method uses the empirical quantiles of the bootstrap distribution directly:

$$
\text{CI}_{1-\alpha} = [T^*_{(\alpha/2)}, T^*_{(1-\alpha/2)}]
$$

where $T^*_{(q)}$ denotes the $q$-th quantile of the ordered bootstrap statistics. This method requires no distributional assumptions and automatically accounts for skewness in the bootstrap distribution.

### Example: Bootstrap for Sample Mean

Consider the problem of estimating the population mean $\mu$ from a sample $\mathbf{x} = \{x_1, \ldots, x_n\}$.

**Original Statistic**: The sample mean is $\bar{x} = \frac{1}{n}\sum_{i=1}^n x_i$

**Bootstrap Procedure**: For each bootstrap replicate $b$, we compute the bootstrap sample mean:
$$\bar{x}^{*(b)} = \frac{1}{n}\sum_{i=1}^n x_i^{*(b)}$$

**Theoretical Properties**: The bootstrap method yields several important results:

- **Unbiasedness**: $\mathbb{E}[\bar{x}^* | \mathbf{x}] = \bar{x}$.

- **Variance**: $\text{Var}(\bar{x}^* | \mathbf{x}) = \frac{\hat{\sigma}^2}{n}$ where $\hat{\sigma}^2 = \frac{1}{n-1}\sum_{i=1}^n (x_i - \bar{x})^2$.

This demonstrates that the bootstrap variance estimate matches the classical theoretical result, providing evidence for the method's validity in this fundamental case.

### Bootstrap Hypothesis Testing

The bootstrap framework extends naturally to hypothesis testing scenarios. Consider testing the null hypothesis $H_0: \theta = \theta_0$ against the alternative $H_1: \theta \neq \theta_0$.

**Bootstrap p-value Procedure**:

1. Compute the observed test statistic $T_{\text{obs}} = T(\mathbf{x})$ from the original sample

2. Generate bootstrap samples under the null hypothesis (often requiring data transformation to satisfy $H_0$)

3. Compute bootstrap test statistics $\{T^{*(1)}, \ldots, T^{*(B)}\}$ from each bootstrap sample

4. Calculate the bootstrap p-value: $p_{\text{boot}} = \frac{\#\{|T^{*(b)}| \geq |T_{\text{obs}}|\}}{B}$

This approach provides a distribution-free method for computing p-values when the null distribution of the test statistic is unknown or intractable.

### Limitations and Considerations

While the non-parametric bootstrap is remarkably versatile, several limitations should be considered:

**Methodological Limitations**:

- **Boundary effects**: Performance degrades when the parameter of interest lies near natural boundaries.

- **Extreme value behavior**: May inadequately capture tail behavior with finite samples.

- **Independence assumption**: Assumes observations are independent and identically distributed.

**Computational Considerations**:

- **Computational intensity**: Requires $B \times n$ resampling operations, which can be substantial for large datasets.

- **Bootstrap sample size**: Choice of $B$ involves trade-offs between accuracy and computational cost.

**Data-specific Issues**:

- **Discrete distributions**: Can perform poorly with discrete data having few unique values.

- **Small sample sizes**: May not provide adequate approximation when $n$ is very small.

Despite these limitations, the non-parametric bootstrap remains one of the most widely applicable and robust methods for statistical inference, particularly when distributional assumptions are questionable or when analytical results are unavailable.


```{python}
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

np.random.seed(42)

true_mean, true_std = 0, 1
true_dist = stats.norm(true_mean, true_std)

def bootstrap_means(sample, n_bootstrap=1000):
    """Bootstrap the sample mean"""
    bootstrap_means = []
    n = len(sample)
    for _ in range(n_bootstrap):
        bootstrap_sample = np.random.choice(sample, size=n, replace=True)
        bootstrap_means.append(np.mean(bootstrap_sample))
    return np.array(bootstrap_means)

sample_sizes = [5, 10, 25, 50]
n_bootstrap = 2000

# First figure: Original samples vs Bootstrap distributions (2x2 grid)
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
fig.suptitle('Bootstrap Convergence to Normal Distribution', fontsize=14)

x_range = np.linspace(-4, 4, 1000)
true_pdf = true_dist.pdf(x_range)

for i, n in enumerate(sample_sizes):
    row = i // 2
    col = i % 2
    
    sample = np.random.normal(true_mean, true_std, n)
    boot_means = bootstrap_means(sample, n_bootstrap)
    
    # Bootstrap distributions
    axes[row, col].hist(boot_means, bins=30, alpha=0.7, color='lightcoral', 
                       density=True, label='Bootstrap Distribution')
    
    theoretical_mean = np.mean(sample)
    theoretical_std = np.std(sample, ddof=1) / np.sqrt(n)
    theoretical_x = np.linspace(boot_means.min(), boot_means.max(), 200)
    theoretical_pdf = stats.norm.pdf(theoretical_x, theoretical_mean, theoretical_std)
    axes[row, col].plot(theoretical_x, theoretical_pdf, 'b-', linewidth=2, 
                       label='Theoretical Normal')
    
    axes[row, col].axvline(np.mean(boot_means), color='red', linestyle='--', 
                          linewidth=2, label=f'Mean: {np.mean(boot_means):.2f}')
    
    axes[row, col].set_title(f'Sample Size n = {n}')
    axes[row, col].legend()
    axes[row, col].grid(True, alpha=0.3)
    
    boot_std = np.std(boot_means)
    axes[row, col].text(0.05, 0.95, f'SE: {boot_std:.3f}', 
                       transform=axes[row, col].transAxes, fontsize=10, 
                       verticalalignment='top',
                       bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

plt.tight_layout()
plt.show()

# Second figure: Convergence comparison
fig, ax = plt.subplots(1, 1, figsize=(10, 8))

sample_sizes_detailed = [3, 5, 10, 20, 50]
colors = ['red', 'orange', 'green', 'blue', 'purple']

x_min, x_max = -2, 2
y_positions = np.arange(len(sample_sizes_detailed))

for i, (n, color) in enumerate(zip(sample_sizes_detailed, colors)):
    np.random.seed(42 + i)
    sample = np.random.normal(true_mean, true_std, n)
    boot_means = bootstrap_means(sample, 1000)
    
    hist_counts, hist_bins = np.histogram(boot_means, bins=30, density=True)
    hist_centers = (hist_bins[:-1] + hist_bins[1:]) / 2
    hist_heights = hist_counts * 0.2
    
    y_base = i
    ax.fill_between(hist_centers, y_base, y_base + hist_heights, 
                    alpha=0.6, color=color, label=f'n={n}')
    
    sample_mean = np.mean(sample)
    sample_se = np.std(sample, ddof=1) / np.sqrt(n)
    x_theory = np.linspace(x_min, x_max, 200)
    y_theory = stats.norm.pdf(x_theory, sample_mean, sample_se)
    y_theory_scaled = y_theory * 0.2
    
    ax.plot(x_theory, y_base + y_theory_scaled, 'k-', linewidth=2, alpha=0.8)

ax.set_xlim(x_min, x_max)
ax.set_ylim(-0.5, len(sample_sizes_detailed))
ax.set_xlabel('Bootstrap Sample Mean')
ax.set_ylabel('Sample Size')
ax.set_yticks(y_positions)
ax.set_yticklabels([f'n={n}' for n in sample_sizes_detailed])
ax.set_title('Bootstrap Distribution Convergence\n(Colored: Bootstrap, Black: Theoretical)')
ax.grid(True, alpha=0.3)
ax.legend(loc='upper right')

plt.tight_layout()
plt.show()
```


## Parametric Bootstrap

### Motivation and Framework

The **parametric bootstrap** assumes your data follows a specific distribution (like normal or exponential). Instead of resampling from your original data, you:

1. Estimate the parameters of the assumed distribution
2. Generate new samples from that fitted distribution

This is like using additional knowledge to guide your bootstrap sampling, similar to how informed proposal distributions improve particle filtering.

### Parametric Bootstrap Procedure

::: {.callout-note}
## Algorithm: Parametric Bootstrap

**Input**: Original sample $\mathbf{x}$, assumed distribution family, number of bootstrap samples $B$

1. **Estimate**: Fit the distribution to get parameter estimate $\hat{\boldsymbol{\theta}}$

**For** $b = 1, 2, \ldots, B$:

2. **Generate**: Draw new sample $\mathbf{x}^{*(b)}$ from the fitted distribution
3. **Compute**: Calculate statistic $T^{*(b)} = T(\mathbf{x}^{*(b)})$

**Output**: Bootstrap distribution $\{T^{*(1)}, T^{*(2)}, \ldots, T^{*(B)}\}$
:::

### When to Use Parametric Bootstrap

**Advantages**:
- More accurate when your distributional assumption is correct
- Better at capturing extreme values and tail behavior  
- Works better with small sample sizes
- Produces smooth distributions even from discrete data

**Disadvantages**:
- Poor performance if you choose the wrong distribution
- Can introduce bias from model misspecification

### Example: Normal Distribution

Suppose your data is normally distributed and you want to bootstrap the sample variance $S^2$.

**Step 1 - Estimate parameters**:
$$\hat{\mu} = \bar{x}, \quad \hat{\sigma}^2 = \frac{1}{n-1}\sum_{i=1}^n (x_i - \bar{x})^2$$

**Step 2 - Bootstrap procedure**:
Generate each bootstrap sample from $\mathcal{N}(\hat{\mu}, \hat{\sigma}^2)$ and compute the variance.

The parametric bootstrap will approximate the known $\chi^2$ distribution, while non-parametric bootstrap gives a discrete approximation.

### Example: Exponential Distribution  

For exponentially distributed data, bootstrap the sample mean $\bar{X}$.

**Parameter estimate**: $\hat{\lambda} = \frac{1}{\bar{x}}$

**Bootstrap procedure**: Generate each bootstrap sample from $\text{Exp}(\hat{\lambda})$.

When the exponential assumption is correct, this provides exact inference using the known $\chi^2$ distribution properties.

```{python}
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

np.random.seed(42)

def bootstrap_statistic_nonparametric(data, statistic_func, n_bootstrap=1000):
    """Non-parametric bootstrap"""
    bootstrap_stats = []
    n = len(data)
    for _ in range(n_bootstrap):
        bootstrap_sample = np.random.choice(data, size=n, replace=True)
        bootstrap_stats.append(statistic_func(bootstrap_sample))
    return np.array(bootstrap_stats)

def bootstrap_statistic_parametric(data, distribution, statistic_func, n_bootstrap=1000):
    """Parametric bootstrap"""
    params = distribution.fit(data)
    n = len(data)
    
    bootstrap_stats = []
    for _ in range(n_bootstrap):
        bootstrap_sample = distribution.rvs(*params, size=n)
        bootstrap_stats.append(statistic_func(bootstrap_sample))
    return np.array(bootstrap_stats)

def probability_above_threshold(x, threshold=8):
    """Estimate P(X > threshold)"""
    return np.mean(x > threshold)

# Generate sample from normal distribution
n_samples = 25
true_mu, true_sigma = 5, 1.5
n_bootstrap = 2000

normal_data = np.random.normal(loc=true_mu, scale=true_sigma, size=n_samples)
true_prob = 1 - stats.norm.cdf(8, loc=true_mu, scale=true_sigma)

# Bootstrap estimates
nonparam_probs = bootstrap_statistic_nonparametric(normal_data, 
                                                  lambda x: probability_above_threshold(x, 8), 
                                                  n_bootstrap)
param_probs = bootstrap_statistic_parametric(normal_data, stats.norm, 
                                            lambda x: probability_above_threshold(x, 8), 
                                            n_bootstrap)

# Create visualization
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Left: Sample data and fitted distribution
axes[0].hist(normal_data, bins=15, alpha=0.7, color='lightblue', 
             density=True, edgecolor='black', label='Sample data')

mu_hat, sigma_hat = stats.norm.fit(normal_data)
x_range = np.linspace(-1, 10, 300)
fitted_curve = stats.norm.pdf(x_range, mu_hat, sigma_hat)

axes[0].plot(x_range, fitted_curve, 'r-', linewidth=2, label='Fitted normal')
axes[0].axvline(8, color='red', linestyle='--', linewidth=2, label='Threshold')
axes[0].fill_between(x_range[x_range > 8], fitted_curve[x_range > 8], 
                    alpha=0.3, color='red')
axes[0].set_title('Sample Data and Fitted Distribution')
axes[0].legend()
axes[0].grid(True, alpha=0.3)
axes[0].set_xlim(-1, 10)

# Right: Bootstrap sample comparison
np.random.seed(123)
nonparam_sample = np.random.choice(normal_data, size=n_samples, replace=True)
param_sample = stats.norm.rvs(mu_hat, sigma_hat, size=n_samples)

axes[1].hist(nonparam_sample, bins=12, alpha=0.7, color='blue', 
             density=True, label='Non-parametric', edgecolor='darkblue')
axes[1].hist(param_sample, bins=12, alpha=0.7, color='red', 
             density=True, label='Parametric', edgecolor='darkred')
axes[1].axvline(8, color='red', linestyle='--', linewidth=2, label='Threshold')
axes[1].set_title('Bootstrap Sample Comparison')
axes[1].legend()
axes[1].grid(True, alpha=0.3)
axes[1].set_xlim(-1, 10)

plt.tight_layout()
plt.show()

# Results
nonparam_mean = np.mean(nonparam_probs)
param_mean = np.mean(param_probs)
nonparam_bias = abs(nonparam_mean - true_prob)
param_bias = abs(param_mean - true_prob)

print(f"True P(X > 8): {true_prob:.4f}")
print(f"Non-parametric estimate: {nonparam_mean:.4f} (bias: {nonparam_bias:.4f})")
print(f"Parametric estimate: {param_mean:.4f} (bias: {param_bias:.4f})")

```

### Comparison: Parametric vs Non-parametric

| Aspect | Non-parametric | Parametric |
|--------|---------------|------------|
| **Assumptions** | Minimal (i.i.d. data) | Strong (distributional family) |
| **Robustness** | High | Low (sensitive to model misspecification) |
| **Efficiency** | Lower when model is correct | Higher when model is correct |
| **Tail behavior** | Limited by sample | Can extrapolate beyond sample |
| **Computational cost** | Resampling only | Parameter estimation + generation |
| **Small samples** | Can be unstable | Often more stable |

### Choosing Between Bootstrap Methods

The choice between parametric and non-parametric bootstrap depends on the balance between model assumptions and statistical efficiency.

**Use Non-parametric Bootstrap when**:

- Uncertain about distributional assumptions.
- Robustness is more important than efficiency.
- Sample size is large.
- Exploring data without strong prior beliefs.

**Use Parametric Bootstrap when**:

- Confident in the parametric model.
- Sample size is small.
- Need to extrapolate beyond observed data.
- Theoretical distribution is well-established.
- Computational efficiency is important.

**Diagnostic Approach**:

1. Compare parametric and non-parametric bootstrap results.
2. If similar: parametric assumptions likely reasonable.
3. If different: investigate model assumptions or prefer non-parametric.
4. Use residual plots and goodness-of-fit tests to validate parametric assumptions.
