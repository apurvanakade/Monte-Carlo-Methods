<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-03-24">

<title>9&nbsp; Metropolis–Hastings Algorithm – Monte Carlo Methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./variance_reduction.html" rel="next">
<link href="./ising.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-1e7bc0a9cbfa8b582ec864d515532ff3.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./mh.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Metropolis–Hastings Algorithm</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Monte Carlo Methods</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Monte Carlo Methods</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./rng.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Random Number Generators</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sampling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Sampling From a Probability Distribution</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./accept_reject.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Rejection Sampling</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./SDE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Stochastic Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./markov_chains.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gibbs_2d.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Gibbs 2D</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ising.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Ising Model</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./mh.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Metropolis–Hastings Algorithm</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./variance_reduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Variance Reduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./mmn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">M/M/n Queue</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bootstrap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Bootstrap</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./hidden_markov.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Hidden Markov Chains</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-random-walks" id="toc-sec-random-walks" class="nav-link active" data-scroll-target="#sec-random-walks"><span class="header-section-number">9.1</span> Random Walks Metropolis–Hastings Algorithm</a>
  <ul class="collapse">
  <li><a href="#proposal-distribution" id="toc-proposal-distribution" class="nav-link" data-scroll-target="#proposal-distribution"><span class="header-section-number">9.1.1</span> Proposal Distribution</a></li>
  <li><a href="#choosing-the-proposal-distribution" id="toc-choosing-the-proposal-distribution" class="nav-link" data-scroll-target="#choosing-the-proposal-distribution"><span class="header-section-number">9.1.2</span> Choosing the Proposal Distribution</a></li>
  </ul></li>
  <li><a href="#metropolishastings-algorithm" id="toc-metropolishastings-algorithm" class="nav-link" data-scroll-target="#metropolishastings-algorithm"><span class="header-section-number">9.2</span> Metropolis–Hastings Algorithm</a>
  <ul class="collapse">
  <li><a href="#structure-of-metropolishastings-algorithm" id="toc-structure-of-metropolishastings-algorithm" class="nav-link" data-scroll-target="#structure-of-metropolishastings-algorithm"><span class="header-section-number">9.2.1</span> Structure of Metropolis–Hastings Algorithm</a></li>
  <li><a href="#proposal-distribution-1" id="toc-proposal-distribution-1" class="nav-link" data-scroll-target="#proposal-distribution-1"><span class="header-section-number">9.2.2</span> Proposal Distribution</a></li>
  <li><a href="#acceptance-criterion" id="toc-acceptance-criterion" class="nav-link" data-scroll-target="#acceptance-criterion"><span class="header-section-number">9.2.3</span> Acceptance Criterion</a></li>
  </ul></li>
  <li><a href="#symmetric-proposal-distribution" id="toc-symmetric-proposal-distribution" class="nav-link" data-scroll-target="#symmetric-proposal-distribution"><span class="header-section-number">9.3</span> Symmetric Proposal Distribution</a></li>
  <li><a href="#metropolis-markov-chain" id="toc-metropolis-markov-chain" class="nav-link" data-scroll-target="#metropolis-markov-chain"><span class="header-section-number">9.4</span> Metropolis Markov Chain</a>
  <ul class="collapse">
  <li><a href="#detailed-balance-equations" id="toc-detailed-balance-equations" class="nav-link" data-scroll-target="#detailed-balance-equations"><span class="header-section-number">9.4.1</span> Detailed Balance Equations</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Metropolis–Hastings Algorithm</span></h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 24, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- - random walks and uniform sampling
- general algorithm
- proof of detailed balance equations?
- acceptance ratio vs convergence


- programming assignment:
  - generate from non-convex region
  - plot acceptance ratio vs ESS? What is this u-shaped graph?
  - generate from bivariate exponential -->
<p>Metropolis–Hastings algorithm is a Markov Chain Monte Carlo (MCMC) method used to sample from a probability distribution. It is a type of a rejection sampling algorithm where we generate a sequence of samples from a target distribution by proposing a new sample and accepting or rejecting it based on a certain criterion. The algorithm is widely used in Bayesian statistics, statistical physics, and machine learning.</p>
<p>We’ll start a few examples to understand the algorithm and then discuss the general algorithm.</p>
<section id="sec-random-walks" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="sec-random-walks"><span class="header-section-number">9.1</span> Random Walks Metropolis–Hastings Algorithm</h2>
<p>Consider a region <span class="math inline">\(\Omega\)</span> in <span class="math inline">\(\mathbb{R}^n\)</span>. Suppose we want to sample uniformly from this region. One way to do this is through rejection sampling. We envelope the region in simple shape like a cube and sample uniformly from the cube. If the sample lies in the region <span class="math inline">\(\Omega\)</span>, we accept it, otherwise we reject it. The efficiency of this method depends on the ratio of the volume of the cube to the volume of the region <span class="math inline">\(\Omega\)</span>. If the region is highly non-convex, this ratio can be very small and the rejection sampling can be very inefficient.</p>
<p>An alternative method is to use random walks. We start at a point <span class="math inline">\(x_0\)</span> in the region <span class="math inline">\(\Omega\)</span> and take a random step in a random direction. If the new point <span class="math inline">\(x_1\)</span> is in the region <span class="math inline">\(\Omega\)</span>, we accept it, otherwise we stay at the point <span class="math inline">\(x_0\)</span>. We repeat this process to generate a sequence of points. This method is more efficient than rejection sampling for highly non-convex regions.</p>
<p>The rationale behind this is that if a point is in the region <span class="math inline">\(\Omega\)</span>, then a point near it is also likely to be in the region. We can use this idea to sample from a probability distribution. The random walk Metropolis–Hastings algorithm for generating <span class="math inline">\(N\)</span> samples from a region <span class="math inline">\(\Omega\)</span> is as follows:</p>
<ol type="1">
<li>Start at a point <span class="math inline">\(x_0\)</span> in the region <span class="math inline">\(\Omega\)</span>.</li>
<li>For <span class="math inline">\(i = 0, 1, \ldots, N-1\)</span>:
<ol type="1">
<li>Generate a random step <span class="math inline">\(\sigma x\)</span>.</li>
<li>Compute the new point <span class="math inline">\(y\)</span> <strong>near</strong> <span class="math inline">\(x_i\)</span>.</li>
<li>If <span class="math inline">\(y\)</span> is in the region <span class="math inline">\(\Omega\)</span>,
<ol type="1">
<li>Set <span class="math inline">\(x_{i+1} = y\)</span>.</li>
</ol></li>
<li>Else,
<ol type="1">
<li>Set <span class="math inline">\(x_{i+1} = x_i\)</span>.</li>
</ol></li>
</ol></li>
<li>Return the sequence of points <span class="math inline">\(x_0, x_1, \ldots, x_{N-1}\)</span>.</li>
</ol>
<p>This is an example of a Metropolis–Hastings algorithm. The acceptance criterion is that the <em>new point <span class="math inline">\(y\)</span> should be in the region <span class="math inline">\(\Omega\)</span></em>.</p>
<section id="proposal-distribution" class="level3" data-number="9.1.1">
<h3 data-number="9.1.1" class="anchored" data-anchor-id="proposal-distribution"><span class="header-section-number">9.1.1</span> Proposal Distribution</h3>
<p>The missing piece in the above algorithm is the method to generate a new point <span class="math inline">\(y\)</span> near the current point <span class="math inline">\(x_i\)</span>. This is done using a <strong>proposal distribution</strong>. The proposal distribution can be almost of any form, but it should be easy to sample from. The choice of the proposal distribution is crucial for the efficiency of the algorithm. A good proposal distribution should be able to explore the region <span class="math inline">\(\Omega\)</span> efficiently.</p>
<p>In the case of random walks, there are two common choices for the proposal distribution:</p>
<ol type="1">
<li><strong>Gaussian proposal</strong>: We sample a new point from a Gaussian distribution centered at the current point <span class="math inline">\(x_i\)</span> with a certain variance.</li>
<li><strong>Uniform proposal</strong>: We sample a new point from a uniform distribution in a neighborhood of the current point <span class="math inline">\(x_i\)</span>.</li>
</ol>
<div id="exm-L-shape" class="theorem example">
<p><span class="theorem-title"><strong>Example 9.1</strong></span> Consider the L-shaped region in <span class="math inline">\(\mathbb{R}^2\)</span> as shown below. This is a non-convex region and rejection sampling would only provide an efficiency of <span class="math inline">\(0.1 + 0.1 - 0.01 = 0.18\)</span>. We’ll use the Metropolis–Hastings algorithm to sample from this region with higher efficiency.</p>
<div id="3f7b96a1" class="cell" data-execution_count="3">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="mh_files/figure-html/cell-3-output-1.png" width="571" height="411" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The images below show scatter plots for the samples generated using the Metropolis–Hastings algorithm with four different choices of the Gaussian proposal distribution with standard deviations <span class="math inline">\(1\)</span>, <span class="math inline">\(0.5\)</span>, <span class="math inline">\(0.2\)</span>, and <span class="math inline">\(0.01\)</span>. The plots to the right are the running averages of the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> coordinates. The scatter plot and the running averages provide a visual representation of the convergence of the samples to the target distribution.</p>
</div>
<div id="0d039b86" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="mh_files/figure-html/cell-5-output-1.png" width="800" height="411" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="038273ec" class="cell" data-execution_count="6">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="mh_files/figure-html/cell-6-output-1.png" width="794" height="411" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="23edb5fd" class="cell" data-execution_count="7">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="mh_files/figure-html/cell-7-output-1.png" width="794" height="411" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="4230089c" class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="mh_files/figure-html/cell-8-output-1.png" width="794" height="411" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="choosing-the-proposal-distribution" class="level3" data-number="9.1.2">
<h3 data-number="9.1.2" class="anchored" data-anchor-id="choosing-the-proposal-distribution"><span class="header-section-number">9.1.2</span> Choosing the Proposal Distribution</h3>
<p>Notice that there is a tradeoff between the acceptance rate and the rate of convergence. In the above example,</p>
<ul>
<li>The proposal distribution with <span class="math inline">\(\sigma = 1\)</span> has the lowest acceptance rate but the samples are well spread out and the underlying markov chain converges quickly.</li>
<li>The proposal distribution with <span class="math inline">\(\sigma = 0.01\)</span> has the highest acceptance rate but the samples are clustered and the underlying markov chain converges slowly. In the above simulation, even after <span class="math inline">\(10^5\)</span> samples (most of which are accepted), the samples are still clustered.</li>
</ul>
<p>Both of these are undesirable. We need to choose a proposal distribution that has a good balance between the acceptance rate and the rate of convergence.</p>
<p>We see that for <span class="math inline">\(\sigma = 0.5\)</span>, the samples are well spread out and the underlying markov chain converges quickly to the target distribution. This is a good choice for the proposal distribution. However, the acceptance rate is <span class="math inline">\(0.07\)</span> which is lower than the acceptance rate for naive rejection sampling AND the generated samples are correlated. It is better to use rejection sampling than to use this proposal distribution.</p>
<p>For <span class="math inline">\(\sigma = 0.2\)</span>, the acceptance rate is <span class="math inline">\(0.3\)</span> which is better than the acceptance rate for naive rejection sampling. The samples are well spread out and the underlying markov chain converges quickly, although not as quickly as for <span class="math inline">\(\sigma = 0.5.\)</span> For this example, <span class="math inline">\(\sigma = 0.2\)</span> is a good choice for the proposal distribution. We can fine tune this parameter to get a better acceptance rate, if needed.</p>
</section>
</section>
<section id="metropolishastings-algorithm" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="metropolishastings-algorithm"><span class="header-section-number">9.2</span> Metropolis–Hastings Algorithm</h2>
<p>The general algorithm for the Metropolis–Hastings algorithm is an algorithm for generating a sequence of samples from a probability distribution <span class="math inline">\(p(x)\)</span>.</p>
<section id="structure-of-metropolishastings-algorithm" class="level3" data-number="9.2.1">
<h3 data-number="9.2.1" class="anchored" data-anchor-id="structure-of-metropolishastings-algorithm"><span class="header-section-number">9.2.1</span> Structure of Metropolis–Hastings Algorithm</h3>
<p>The above example illustrates the general structure of the Metropolis–Hastings algorithm for sampling from a probability distribution <span class="math inline">\(p(x)\)</span>. The algorithm is as follows:</p>
<ol type="1">
<li><strong>Initialization</strong>: Start at a point <span class="math inline">\(x_0\)</span>.</li>
<li>For <span class="math inline">\(i = 0, 1, \ldots, N-1\)</span>:
<ol type="1">
<li>Generate a proposal <span class="math inline">\(y\)</span> close to <span class="math inline">\(x_i\)</span>.</li>
<li>Evaluate the acceptance ratio <span class="math inline">\(\alpha (y | x_i)\)</span>.</li>
<li>Accept <span class="math inline">\(y\)</span> with probability <span class="math inline">\(\alpha (y | x_i)\)</span>.
<ol type="1">
<li>If accepted, set <span class="math inline">\(x_{i+1} = y\)</span>.</li>
<li>Else, set <span class="math inline">\(x_{i+1} = x_i\)</span>.</li>
</ol></li>
</ol></li>
<li>Return the sequence of points <span class="math inline">\(x_0, x_1, \ldots, x_{N-1}\)</span>.</li>
</ol>
</section>
<section id="proposal-distribution-1" class="level3" data-number="9.2.2">
<h3 data-number="9.2.2" class="anchored" data-anchor-id="proposal-distribution-1"><span class="header-section-number">9.2.2</span> Proposal Distribution</h3>
<p>For the MH algorithm, we need to specify a <strong>proposal distribution</strong> for generating “nearby points”. This is a joint distribution <span class="math inline">\(q(x, y)\)</span> for two random variables <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. However, for running the algorithm we only need the conditional distribution <span class="math inline">\(q(y | x)\)</span>. As such, it’s more common to say that the proposal distribution is the conditional distribution <span class="math inline">\(q(y | x)\)</span>. We think of <span class="math inline">\(x\)</span> as the current point and <span class="math inline">\(y\)</span> as the proposed point so that the proposal distribution <span class="math inline">\(q(y | x)\)</span> is <em>the distribution of the proposed point <span class="math inline">\(y\)</span> given the current point <span class="math inline">\(x\)</span></em>.</p>
<p>In the <a href="#exm-L-shape" class="quarto-xref">Example&nbsp;<span>9.1</span></a>, the proposal distribution <span class="math inline">\(q(y|x)\)</span> was a Gaussian distribution centered at <span class="math inline">\(x\)</span> with a chosen variance,</p>
<p><span class="math display">\[\begin{align*}
q(y | x) = \mathcal{N}(y ; x, \sigma^2 I).
\end{align*}\]</span></p>
<p>The proposal distribution can be any distribution that is easy to sample from. The choice of the proposal distribution is crucial for the efficiency of the algorithm.</p>
</section>
<section id="acceptance-criterion" class="level3" data-number="9.2.3">
<h3 data-number="9.2.3" class="anchored" data-anchor-id="acceptance-criterion"><span class="header-section-number">9.2.3</span> Acceptance Criterion</h3>
<p>Once we generate a proposal <span class="math inline">\(y\)</span>, we need to evaluate an acceptance criterion for <span class="math inline">\(w\)</span>. The acceptance criterion is based on the ratio of the target distribution <span class="math inline">\(p(x)\)</span> and the proposal distribution <span class="math inline">\(q(y | x)\)</span>. We calculate the acceptance ratio as</p>
<p><span class="math display">\[
\alpha (y | x) = \min \left\{ \frac{p(y)}{p(x)} \cdot \frac{q(x | y)}{q(y | x)}, 1 \right\}.
\]</span></p>
<p>The complete Metropolis–Hastings algorithm is as follows:</p>
<ol type="1">
<li><strong>Initialization</strong>: Start at a point <span class="math inline">\(x_0\)</span>.</li>
<li>For <span class="math inline">\(i = 0, 1, \ldots, N-1\)</span>:
<ol type="1">
<li><p>Generate a proposal <span class="math inline">\(y\)</span> from the proposal distribution <span class="math inline">\(q(y | x_i)\)</span>.</p></li>
<li><p>Compute the acceptance ratio <span class="math display">\[
\alpha(y | x) = \min\left\{ \frac{p(y)}{p(x)} \cdot \frac{q(x | y)}{q(y | x)}, 1 \right\}.
\]</span></p></li>
<li><p>Accept <span class="math inline">\(y\)</span> with probability <span class="math inline">\(\alpha(y | x)\)</span>:</p>
<ul>
<li>If <span class="math inline">\(y\)</span> is accepted, set <span class="math inline">\(x_{i+1} = y\)</span>.</li>
<li>Otherwise, set <span class="math inline">\(x_{i+1} = x_i\)</span>.</li>
</ul></li>
</ol></li>
<li>Return the sequence of points <span class="math inline">\(x_0, x_1, \ldots, x_{N-1}\)</span>.</li>
</ol>
<p>We can expand the algorithm further as follows:</p>
<ol type="1">
<li><strong>Initialization</strong>: Start at a point <span class="math inline">\(x_0\)</span>.</li>
<li>For <span class="math inline">\(i = 0, 1, \ldots, N-1\)</span>:
<ol type="1">
<li>Generate a proposal <span class="math inline">\(y \sim q(y | x_i)\)</span>.</li>
<li>Compute <span class="math display">\[ \alpha_1 = p(y) \cdot q(x_i | y), \quad \alpha_2 = p(x_i) \cdot q(y | x_i). \]</span></li>
<li>If <span class="math inline">\(\alpha_1 \geq \alpha_2\)</span>,
<ol type="1">
<li>Set <span class="math inline">\(x_{i+1} = y\)</span>.</li>
</ol></li>
<li>Else,
<ol type="1">
<li>Generate a random number <span class="math inline">\(u \sim \text{Uniform}(0, 1)\)</span>.</li>
<li>If <span class="math inline">\(u &lt; \alpha_1 / \alpha_2\)</span>,
<ol type="1">
<li>Set <span class="math inline">\(x_{i+1} = y\)</span>.</li>
</ol></li>
<li>Else,
<ol type="1">
<li>Set <span class="math inline">\(x_{i+1} = x_i\)</span>.</li>
</ol></li>
</ol></li>
</ol></li>
<li>Return the sequence of points <span class="math inline">\(x_0, x_1, \ldots, x_{N-1}\)</span>.</li>
</ol>
</section>
</section>
<section id="symmetric-proposal-distribution" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="symmetric-proposal-distribution"><span class="header-section-number">9.3</span> Symmetric Proposal Distribution</h2>
<p>Often we use a symmetric proposal distribution <span class="math inline">\(q(y | x) = q(x | y)\)</span>. In this case, the acceptance ratio simplifies to</p>
<p><span class="math display">\[
\alpha(y | x) = \min \left\{ \frac{p(y)}{p(x)}, 1 \right\}.
\]</span></p>
<p>The Metropolis algorithm is a special case of the Metropolis–Hastings algorithm where the proposal distribution is symmetric. The Metropolis algorithm is widely used in practice. The algorithm is as follows:</p>
<ol type="1">
<li><strong>Initialization</strong>: Start at a point <span class="math inline">\(x_0\)</span>.</li>
<li>For <span class="math inline">\(i = 0, 1, \ldots, N-1\)</span>:
<ol type="1">
<li>Generate a proposal <span class="math inline">\(y \sim q(y | x_i)\)</span>.</li>
<li>If <span class="math inline">\(p(y) \geq p(x_i)\)</span>,
<ol type="1">
<li>Set <span class="math inline">\(x_{i+1} = y\)</span>.</li>
</ol></li>
<li>Else,
<ol type="1">
<li>Generate a random number <span class="math inline">\(u \sim \text{Uniform}(0, 1)\)</span>.</li>
<li>If <span class="math inline">\(u &lt; p(y) / p(x_i)\)</span>,
<ol type="1">
<li>Set <span class="math inline">\(x_{i+1} = y\)</span>.</li>
</ol></li>
<li>Else,
<ol type="1">
<li>Set <span class="math inline">\(x_{i+1} = x_i\)</span>.</li>
</ol></li>
</ol></li>
</ol></li>
<li>Return the sequence of points <span class="math inline">\(x_0, x_1, \ldots, x_{N-1}\)</span>.</li>
</ol>
<div id="exm-Metropolis-to-random-walk" class="theorem example">
<p><span class="theorem-title"><strong>Example 9.2</strong></span> If <span class="math inline">\(p(x)\)</span> is a uniform distribution over the region <span class="math inline">\(\Omega\)</span>, then the Metropolis algorithm reduces to the random walk Metropolis–Hastings algorithm. In this case, the acceptance ratio becomes</p>
<p><span class="math display">\[
\alpha(y | x) = \begin{cases}
1, &amp; \text{if } y \in \Omega, \\
0, &amp; \text{if } y \notin \Omega.
\end{cases}
\]</span></p>
<p>This means that we always accept a proposal <span class="math inline">\(y\)</span> if it is in the region <span class="math inline">\(\Omega\)</span> and reject it otherwise. This is equivalent to the random walk Metropolis–Hastings algorithm in <a href="#sec-random-walks" class="quarto-xref"><span>Section 9.1</span></a>.</p>
<p>Several other algorithms, such as rejection sampling, random walks on graphs, and Gibbs sampling, can be viewed as special cases of the Metropolis–Hastings algorithm.</p>
</div>
</section>
<section id="metropolis-markov-chain" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="metropolis-markov-chain"><span class="header-section-number">9.4</span> Metropolis Markov Chain</h2>
<p>If the target distribution <span class="math inline">\(p(x)\)</span> is defined over the sample space <span class="math inline">\(\Omega\)</span>, then the Metropolis–Hastings algorithm generates a Markov chain with state space <span class="math inline">\(\Omega\)</span>.</p>
<p>For simplicity,</p>
<ol type="1">
<li>we will analyze the Metropolis algorithm with a symmetric proposal distribution <span class="math inline">\(q(y | x) = q(x | y)\)</span>, and</li>
<li>we will assume that the target distribution <span class="math inline">\(p(x)\)</span> is defined over a finite sample space <span class="math inline">\(\Omega\)</span>.</li>
</ol>
<p>The transition matrix for the Markov chain is given by</p>
<p><span class="math display">\[
\begin{aligned}
\mathbb{P}(X = b | X = a) = \begin{cases}
q(b | a) &amp; \text{if } p(b) \geq p(a) \text{ and } a \neq b, \\
\frac{p(b)}{p(a)} \cdot q(b | a) &amp; \text{if } p(b) &lt; p(a) \text{ and } a \neq b, \\
q(a | a) + \sum \limits_{b \in \Omega, p(b) &lt; p(a)} q(b | a) \cdot \left(1 - \frac{p(b)}{p(a)}\right) &amp; \text{if } a = b.
\end{cases}
\end{aligned}
\]</span></p>
<p>One can check that this defines a valid transition matrix by showing that the sum of the transition probabilities for each state is <span class="math inline">\(1\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum \limits_{b \in \Omega} \mathbb{P}(X = b | X = a) \\
&amp;= \sum \limits_{p(b) \ge p(a), a \neq b} q(b | a)
+ \sum \limits_{p(b) &lt; p(a)} \frac{p(b)}{p(a)} \cdot q(b | a)
+ q(a|a)
+ \sum \limits_{p(b) &lt; p(a)} q(b | a) \cdot \left(1 - \frac{p(b)}{p(a)}\right) \\
&amp;= \sum \limits_{b \in \Omega} q(b | a) \\
&amp;= 1.
\end{aligned}
\]</span></p>
<section id="detailed-balance-equations" class="level3" data-number="9.4.1">
<h3 data-number="9.4.1" class="anchored" data-anchor-id="detailed-balance-equations"><span class="header-section-number">9.4.1</span> Detailed Balance Equations</h3>
<div id="thm-detailed-balance" class="theorem">
<p><span class="theorem-title"><strong>Theorem 9.1</strong></span> The Metropolis algorithm is reversible with respect to the target distribution <span class="math inline">\(p(x)\)</span>. This means that the Markov chain defined by the Metropolis algorithm satisfies the detailed balance equations:</p>
<p><span class="math display">\[
p(a) \cdot \mathbb{P}(X = b | X = a) = p(b) \cdot \mathbb{P}(X = a | X = b).
\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>We only need check the detailed balance equations for the case when <span class="math inline">\(a \neq b\)</span>. The case when <span class="math inline">\(a = b\)</span> is trivial. We make two cases:</p>
<ol type="1">
<li><strong>Case 1</strong>: <span class="math inline">\(p(a) \neq p(b)\)</span>.</li>
</ol>
<p>Without loss of generality, assume that <span class="math inline">\(p(a) &lt; p(b)\)</span>. Then we have</p>
<p><span class="math display">\[
\begin{aligned}
p(a) \cdot \mathbb{P}(X = b | X = a)
&amp;= p(a) \cdot q(b | a) \\
&amp;= p(a) \cdot q(a | b) \\
&amp;= p(b) \cdot q(a | b) \dfrac{p(a)}{p(b)} \\
&amp;= p(b) \cdot \mathbb{P}(X = a | X = b).
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li><strong>Case 2</strong>: <span class="math inline">\(p(a) = p(b)\)</span>. In this case, we have <span class="math display">\[
\begin{aligned}
p(a) \cdot \mathbb{P}(X = b | X = a)
&amp;= p(a) \cdot q(b | a) \\
&amp;= p(b) \cdot q(a | b) \\
&amp;= p(b) \cdot \mathbb{P}(X = a | X = b).
\end{aligned}
\]</span> Thus, in both cases, we have shown that the detailed balance equations hold. This completes the proof.</li>
</ol>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ising.html" class="pagination-link" aria-label="Ising Model">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Ising Model</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./variance_reduction.html" class="pagination-link" aria-label="Variance Reduction">
        <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Variance Reduction</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>